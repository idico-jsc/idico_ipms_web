#!/usr/bin/env node

import { readdirSync, statSync, writeFileSync } from 'fs';
import { join, relative } from 'path';
import { fileURLToPath } from 'url';
import { dirname } from 'path';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const APP_DIR = join(__dirname, '../src/app');
const OUTPUT_FILE = join(__dirname, '../src/features/navigation/utils/route-helpers.ts');

/**
 * Find all page.tsx files in app directory
 */
function findPageFiles(dir, baseDir = dir) {
  const results = [];
  const items = readdirSync(dir);

  for (const item of items) {
    const fullPath = join(dir, item);
    const stat = statSync(fullPath);

    if (stat.isDirectory()) {
      results.push(...findPageFiles(fullPath, baseDir));
    } else if (item === 'page.tsx' || item === 'page.ts') {
      const relativePath = relative(baseDir, dirname(fullPath));
      results.push(relativePath);
    }
  }

  return results;
}

/**
 * Convert file path to URL path
 * - Remove route groups: (auth), (main), etc.
 * - Keep dynamic segments: [token]
 * - Root becomes /
 */
function filePathToUrlPath(filePath) {
  if (!filePath || filePath === '.') return '/';

  const segments = filePath.split('/').filter(Boolean);
  const cleanedSegments = segments
    .filter(segment => !segment.startsWith('(') || !segment.endsWith(')'));

  if (cleanedSegments.length === 0) return '/';

  return '/' + cleanedSegments.join('/');
}

/**
 * Convert URL path to route name (camelCase)
 * /reset-password/[token] => resetPassword
 * / => home
 */
function urlPathToRouteName(urlPath) {
  if (urlPath === '/') return 'home';

  const segments = urlPath
    .split('/')
    .filter(Boolean)
    .filter(segment => !segment.startsWith('['));

  const name = segments
    .map((segment, index) => {
      const camelSegment = segment.replace(/-([a-z])/g, (_, letter) => letter.toUpperCase());
      return index === 0 ? camelSegment : camelSegment.charAt(0).toUpperCase() + camelSegment.slice(1);
    })
    .join('');

  return name || 'index';
}

/**
 * Extract dynamic param names from URL path
 * /reset-password/[token] => ['token']
 * /user/[id]/post/[postId] => ['id', 'postId']
 */
function extractDynamicParams(urlPath) {
  const matches = urlPath.match(/\[([^\]]+)\]/g);
  if (!matches) return [];
  return matches.map(match => match.slice(1, -1));
}

/**
 * Generate TypeScript type for route params
 */
function generateParamType(params) {
  if (params.length === 0) return 'never';

  const paramTypes = params.map(param => `${param}: string`).join('; ');
  return `{ ${paramTypes} }`;
}

/**
 * Generate routes object and types
 */
function generateRoutesFile(routes) {
  const imports = `/**
 * Type-safe Route Helpers (Auto-generated)
 *
 * This file is automatically generated from your app directory structure.
 * DO NOT EDIT MANUALLY - Run 'npm run generate:routes' to regenerate.
 *
 * Usage:
 * \`\`\`ts
 * import { getPath } from '@/features/navigation';
 *
 * // Simple route
 * getPath.home() // => '/'
 * getPath.login() // => '/login'
 *
 * // With dynamic params
 * getPath.resetPassword({ token: 'abc123' }) // => '/reset-password/abc123'
 *
 * // With query strings (use 'qs' key)
 * getPath.home({ qs: { redirect: '/dashboard' } }) // => '/?redirect=/dashboard'
 * getPath.resetPassword({ token: 'abc', qs: { returnUrl: '/profile' } })
 * // => '/reset-password/abc?returnUrl=/profile'
 * \`\`\`
 */

type QueryParams = Record<string, string | number | boolean | undefined>;
type WithQueryString<T = never> = T extends never
  ? { qs?: QueryParams }
  : T & { qs?: QueryParams };

/**
 * Build query string from params object
 */
function buildQueryString(params: QueryParams): string {
  const filtered = Object.entries(params).filter(
    ([, value]) => value !== undefined && value !== null
  );

  if (filtered.length === 0) return "";

  const searchParams = new URLSearchParams();
  filtered.forEach(([key, value]) => {
    searchParams.append(key, String(value));
  });

  return \`?\${searchParams.toString()}\`;
}

/**
 * Route builder helper
 */
function createRoute<TParams extends Record<string, string> = never>(
  path: string,
  paramKeys: string[] = []
) {
  return (
    params?: WithQueryString<TParams>
  ): string => {
    if (!params) return path;

    let finalPath = path;
    const queryParams: QueryParams = {};

    // Extract query string params
    if ('qs' in params && params.qs) {
      Object.assign(queryParams, params.qs);
    }

    // Replace path params
    paramKeys.forEach((key) => {
      if (key in params && params[key as keyof typeof params] !== undefined) {
        finalPath = finalPath.replace(\`[\${key}]\`, String(params[key as keyof typeof params]));
      }
    });

    // Copy remaining params to query string (except 'qs')
    Object.entries(params).forEach(([key, value]) => {
      if (key !== 'qs' && !paramKeys.includes(key) && value !== undefined) {
        queryParams[key] = value as string | number | boolean;
      }
    });

    // Add query string
    const queryString = buildQueryString(queryParams);
    return \`\${finalPath}\${queryString}\`;
  };
}
`;

  // Group routes by category (based on URL structure)
  const routesByCategory = new Map();

  routes.forEach(route => {
    const { urlPath } = route;
    const topLevel = urlPath.split('/')[1] || 'main';

    if (!routesByCategory.has(topLevel)) {
      routesByCategory.set(topLevel, []);
    }
    routesByCategory.get(topLevel).push(route);
  });

  // Generate routes object
  let routesObject = '\n/**\n * Application Routes\n * Auto-generated based on app directory structure\n */\nexport const getPath = {\n';

  // Sort categories and routes
  const sortedCategories = Array.from(routesByCategory.entries()).sort(([a], [b]) => {
    // Home/main routes first
    if (a === 'main' || a === '') return -1;
    if (b === 'main' || b === '') return 1;
    return a.localeCompare(b);
  });

  sortedCategories.forEach(([category, categoryRoutes], categoryIndex) => {
    const categoryName = category === 'main' || category === '' ? 'Main routes' : `${category.charAt(0).toUpperCase() + category.slice(1)} routes`;
    routesObject += `  // ${categoryName}\n`;

    categoryRoutes
      .sort((a, b) => a.routeName.localeCompare(b.routeName))
      .forEach((route, index) => {
        const { routeName, urlPath, dynamicParams } = route;
        const paramType = dynamicParams.length > 0 ? `<${generateParamType(dynamicParams)}>` : '';
        const paramArray = dynamicParams.length > 0 ? `, [${dynamicParams.map(p => `"${p}"`).join(', ')}]` : '';

        routesObject += `  ${routeName}: createRoute${paramType}("${urlPath}"${paramArray}),\n`;
      });

    if (categoryIndex < sortedCategories.length - 1) {
      routesObject += '\n';
    }
  });

  routesObject += '} as const;\n';

  // Generate types
  const types = `
/**
 * Route type inference
 */
export type Routes = typeof getPath;
export type RouteName = keyof Routes;
`;

  return imports + routesObject + types;
}

/**
 * Main function
 */
function main() {
  console.log('üîç Scanning app directory for routes...');

  const pagePaths = findPageFiles(APP_DIR);
  console.log(`   Found ${pagePaths.length} page(s)`);

  const routes = pagePaths.map(filePath => {
    const urlPath = filePathToUrlPath(filePath);
    const routeName = urlPathToRouteName(urlPath);
    const dynamicParams = extractDynamicParams(urlPath);

    console.log(`   - ${filePath.padEnd(40)} => ${routeName.padEnd(20)} (${urlPath})`);

    return {
      filePath,
      urlPath,
      routeName,
      dynamicParams,
    };
  });

  console.log('\nüìù Generating route-helpers.ts...');
  const fileContent = generateRoutesFile(routes);
  writeFileSync(OUTPUT_FILE, fileContent, 'utf-8');

  console.log(`‚úÖ Generated ${routes.length} route(s) in ${relative(join(__dirname, '..'), OUTPUT_FILE)}`);
}

main();
